---
title: "Session 3 Notes"
author: "Tim Riffe"
date: "2023-07-05"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Functions

What is a function? A function maps some inputs to an output. There
could be one or more inputs, and likewise for outputs.

-   `my_adder` is the name of the function
-   `function()` is the formal way to declare the named object as a
    function (rather than as data)
-   `()` we list the names of the arguments (parameters)
-   `{}` we create the function body; The function body only *sees* the
    arguments. It should not be written to use data objects sitting
    around in your R session. What happens in the function stays in the
    function. Don't be bashful. Main thing is it gets the job done.
-   `return()` is what comes out; nothing else comes out.

```{r}

my_adder <- function(number1, number2){
  the_sum <- number1 + number2
  return(the_sum)
}
my_adder(number1 = 3, number2 = 4)
my_adder(number1 = 3:10, number2 = 4:11)
```

Another function example: Let's make a Gompertz mortality function.
$$ \mu(x) = \alpha e^{\beta x}$$

-    $\mu(x)$ is the force of mortality at age $x$

-   $\alpha$ is a baseline scalar of mortality

-    $\beta$ is the pace of senescence (the proportional increase in
    mortality in each age step)

-   $x$ is age

```{r}
gomp_mx <- function(a, b, age){
  mx <- a * exp(b * age)
  return(mx)
}
```

These are our test parameters
```{r}
age     <- 0:110
alpha   <- 0.0001
beta    <- .08
library(tidyverse)
toymx <- 
  tibble(age = age,
         mx = gomp_mx(a = alpha,
                      b = beta, 
                      age = age))
```

## $q(x)$

$$ q(x) = \frac{\mu(x)}{1 + (1 - a(x)) \cdot \mu(x)}   $$
Make a function called `mx_to_qx()`. It will need arguments `mx` and `ax`. Go ahead

```{r}
ax <- rep(.5, times = 111)
mx <- toymx |> pull(mx)
# mx <- gomp_mx(a,b,age)
mx_to_qx <- function(mx, ax){
  qx <- mx / (1 + (1 - ax) * mx)
  qx[length(qx)] <- 1
  return(qx)
}
qx <- mx_to_qx(mx, ax)
```
Note: Why 111? Because the toy data goes up to age 110, and don't forget age 0 when counting elements.
`rep()` repeats a value `times` times.

`mx <- toymx |> pull(mx)` creates a vector called `mx` by pulling off a column of `toymx`. We could have also just made `mx` directly by using that original function not inside a tibble: `mx <- gomp_mx(a,b,age)`. I just opted to work with toy vectors rather than a tibble, sorry for that.

How to use a function:
```{r}
# toymx |> 
#   mutate(ax = .5,
#          qx = mx_to_qx(mx = mx, ax = ax))
qx <- mx_to_qx(mx, ax)
```

# Convert $q(x)$ to $l(x)$

$$ l(x) = \prod _{i=0}^x 1 - q(i) $$
Except the very first $l(x)$ should be a clean number like 1. 
I suggest using the `cumprod()`.
And recall that you can append a value to a vector with `c()`
Call the function `qx_to_lx()`

```{r}
qx_to_lx <- function(qx, radix = 1){
  lx <- cumprod(1 - qx)
  lx <- c(1,lx)
  lx <- lx[1:length(qx)]
  lx <- radix * lx
  return(lx)
}
lx <- qx_to_lx(qx)
# sum(lx)
# sum(lx) - .5
```

## $d(x)$ is the death distribution

$$d(x) = l(x)q(x)$$
It's also the same as:

$$ d(x) = l(x+1) - l(x)$$
$$ d(x) = -(l(x) - l(x+1)) $$
However, these last two are bit more tedious to code because you need to think about vector lengths. For the first one using `lx` an `qx` everything is already the right length.

```{r}
lxqx_to_dx <- function(lx,qx){
  lx * qx
}
dx <- lxqx_to_dx(lx,qx)
plot(age,lx)
```

# $L(x)$

Lifetable exposure (synthetic exposure) is the area between steps in $l(x)$. We can approximate it using the trapezoid integration method.

$l(x) * 1$ is an overestimate of $L(x)$ because some drop out.
$ d(x)$ is the size of the decrement, of which about 1/2 needs to be included because those dropping out spend on average about 1/2 of their time in the interval. But we need to count the time of those that make it to the end of the interval, not those who die. That's why we do $(1-a(x))$

$$ L(x) = l(x) - (1- a(x)) \cdot d(x)$$

```{r}
lxdx_to_Lx <- function(lx,ax,dx){
  Lx <- lx - (1- ax) * dx
  return(Lx)
}
Lx <- lxdx_to_Lx(lx,ax,dx)

```

# $T(x)$ a helper variable

$$ T(x) = \sum _{i=x}^\omega L(i)$$
`cumsum()` takes a cumulative sum over a vector.
`rev()` can be used to reverse the order of the elements of a vector.
We want a function called `Lx_to_Tx()`
```{r}
Lx_to_Tx <- function(Lx){
  Tx <-
    # start with the Lx by age
    Lx |> 
    # turn it backwards
    rev() |> 
    # then take the cumulative sum
    cumsum() |> 
    # and put it back in the original age order
    rev()
  return(Tx)
}
Tx <- Lx_to_Tx(Lx)
# same thing but harder to read:
# rev(cumsum(rev(Lx)))
```

# $e(x)$

$$ e(x) = \frac{T(x)}{ l(x)}$$
Explainer: $T(x)$ are the synthetic years lived beyond a given age $x$. We can't simply take this as a direct estimate of the expectancy for age $x$ though: it's two small, because it isn't yet conditional on having survived to age $x$: we need to scale it up by making $e(x)$ conditional on survival to $x$.

```{r}
Txlx_to_ex <- function(Tx, lx){
  ex <- Tx / lx
  return(ex)
}
ex <- Txlx_to_ex(Tx, lx)
```

# collect the functions some place handy
